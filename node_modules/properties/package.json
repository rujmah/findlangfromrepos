{
  "name": "properties",
  "version": "1.0.3",
  "description": ".properties parser/stringifier",
  "keywords": [
    "properties",
    "ini",
    "parser",
    "stringifier",
    "config"
  ],
  "author": {
    "name": "Gabriel Llamas",
    "email": "gagle@outlook.com"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/gagle/node-properties.git"
  },
  "engines": {
    "node": ">=0.10"
  },
  "devDependencies": {
    "ini": "*",
    "speedy": "*"
  },
  "license": "MIT",
  "main": "lib",
  "readme": "properties\n==========\n\n_Node.js project_\n\n#### .properties parser/stringifier ####\n\nVersion: 1.0.3\n\n[Specification](http://docs.oracle.com/javase/7/docs/api/java/util/Properties.html#load%28java.io.Reader%29)\n\nThis module implements the Java .properties specification and adds additional features like ini sections, variables (key referencing), namespaces, importing files and much more.\n\nThis is a .properties file parser/stringifier but it can also parse/stringify [ini](#ini) files.\n\n#### Installation ####\n\n```\nnpm install properties\n```\n\n#### Documentation ####\n\n- [JSON](#json)\n- [Sections](#sections)\n- [Variables](#variables)\n\t- [Environment](#environment)\n- [Namespaces](#namespaces)\n- [INI](#ini)\n- [Importing files](#include)\n- [Useful options that you should always use](#useful)\n\n#### Functions ####\n\n- [_module_.parse(data[, options][, callback]) : undefined | Object](#parse)\n- [_module_.stringifier([obj]) : Stringifier](#stringifier)\n- [_module_.stringify(obj[, options][, callback]) : undefined | String](#stringify)\n\n#### Objects ####\n\n- [Stringifier](#Stringifier)\n\n#### Migration from v0.3 to v1\n\n- `load()` and `store()` have been removed. Now `parse()` and `stringify()` can read and write from/to files using the `path` option.\n- `stringify()` has been refactored. Now a `Stringifier` can be used to stringify an object if you want to write sections or comments.\n- The `pretty` option has been removed from `stringify()`.\n- The `replacer` from `stringify()` must be a function. Cannot be an array like in previous versions.\n\n---\n\n<a name=\"json\"></a>\n__JSON__\n\nBy default the value of a property is converted to a Number, Boolean or String. When the `json` option is enabled the value can be also parsed to Array or Object. The value must be a valid json data.\n\nThis is a very powerful feature because you can parse arrays. You can also parse objects but I recommend to use [namespaces](#namespaces) because with objects you have to surround with double quotes each key and if you want to write a multiline object you need to escape the line break.\n\n```\na = [\"string\", 1, true]\n```\n\nIf the namespaces are enabled the following two properties create the same object:\n\n```\na = {\\\n\t\"b\": 1\\\n}\na.b = 1\n```\n\nCreates:\n\n```javascript\n{\n\ta: {\n\t\tb: 1\n\t}\t\n}\n```\n\nTherefore, is much more easier and clear to write `a.b = 1` instead of `a = { \"b\": 1 }`.\n\nYou can also use [variables](#variables). Remember that the value must be a valid json data, the strings must be double quoted.\n\n```\na = string\nb = 1\nc = [\"${a}\", ${b}]\n```\n\n---\n\n<a name=\"sections\"></a>\n__Sections__\n\nINI sections can be enabled with the `sections` option. With them you can better organize your configuration data.\n\n```\napp_name App\n\n[web]\nhostname 10.10.10.10\nport 1234\n\n[db]\nhostname 10.10.10.20\nport 4321\n```\n\nCreates:\n\n```javascript\n{\n\tapp_name: \"App\",\n\tweb: {\n\t\thostname: \"10.10.10.10\",\n\t\tport: 1234\n\t},\n\tdb: {\n\t\thostname: \"10.10.10.20\",\n\t\tport: 4321\n\t}\n}\n```\n\n---\n\n<a name=\"variables\"></a>\n__Variables__\n\nWhen the `variables` option is enabled you can get the value of another key. The value is read __before__ the type conversion. Imagine them like the C macros. They simply copy the characters, they don't care if the value is a number or a string.\n\n```\na = 1\n# b = 1\nb = ${a}\n```\n\nNote: If you are using the `include` option take into account that the variables are local to the file, they cannot be used to access the properties of other files.\n\nIf you need to get the value of a key that belongs to a section prefix the key with the section followed by `|`.\n\n```\na = 1\n[section]\na = 2\n# b = 2\nb = ${section|a}\n```\n\nYou can use the variables anywhere including the variable itself. Look at the [variables](https://github.com/gagle/node-properties/blob/master/examples/variables/variables.js) example for further details.\n\n```\na = 1\n# s1\n[s${a}]\na = b\nb = c\n# d = c\nd = ${s${a}|${s${a}|a}}\n```\n\n<a name=\"environment\"></a>\n__Environment__\n\nYou can also pass external variables with the `vars` option and use their value while the file is being parsed. This is an extremly useful feature because you don't need to change anything from your configuration files if you want to dynamically assign the value of the properties. It could be used to load different configurations depending on the environment. Look at the [vars](https://github.com/gagle/node-properties/blob/master/examples/variables/vars.js) and [environment-vars](https://github.com/gagle/node-properties/blob/master/examples/variables/environment-vars.js) examples for further details.\n\n---\n\n<a name=\"namespaces\"></a>\n__Namespaces__\n\nWhen the `namespaces` option is enabled dot separated keys are parsed as namespaces, that is, they are interpreted as javascript objects.\n\n```\na.b = 1\na.c.d = 2\n\n```\n\nThese properties creates the following object:\n\n```javascript\n{\n\ta: {\n\t\tb: 1,\n\t\tc: {\n\t\t\td: 2\n\t\t}\n\t}\n}\n```\n\nYou can also use sections and variables:\n\n```\n[s1]\na.b = 1\n# a.c.d = 1\na.c.d = ${s1|a.b}\n\n```\n\n```javascript\n{\n\ts1: {\n\t\ta: {\n\t\t\tb: 1,\n\t\t\tc: {\n\t\t\t\td: 1\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\nThe external variables can also be read using namespaces:\n\n```javascript\nvar options = {\n\tvars: {\n\t\ta: {\n\t\t\tb: 1\n\t\t}\n\t}\n};\n```\n\n```\n# a = 1\na = ${a.b}\n```\n\nLook at the [namespaces](https://github.com/gagle/node-properties/blob/master/examples/namespaces/namespaces.js) example for further details.\n\n---\n\n<a name=\"ini\"></a>\n__INI__\n\nThis module implements the .properties specification but there are some options that can be enabled, some of them are the `sections`, `comments`, `separators` and `strict`. With these four options this module can parse INI files. There isn't an official INI specification, each program implements its own features, but there is a de facto standard that says that INI files are just .properties files with sections and the `=` token as a separator.\n\nIf you want to parse INI files hen enable these options:\n\n```javascript\nvar options = {\n\tsections: true,\n\tcomments: \";\", //Some INI files also consider # as a comment, if so, add it, comments: [\";\", \"#\"]\n\tseparators: \"=\",\n\tstrict: true\n};\n```\n\nThe `strict` option says that __only__ the tokens that are specified in the `comments` and `separators` options are used to parse the file. If `strict` is not enabled, the default .properties comment (`#`, `!`) and separator (`=`, `:`) tokens are also used to parse comments and separators. Look at the [ini](https://github.com/gagle/node-properties/tree/master/examples/ini) examples for further details.\n\nNote: The whitespace (`<space>`, `\\t`, `\\f`) is still considered a separator even if `strict` is true.\n\n---\n\n<a name=\"include\"></a>\n__Importing files__\n\nWhen the `include` option is enabled, the `include` key allows you import files. If the path is a directory it tries to load the file `index.properties`. The paths are relative from the __current__ file.\n\nThe imported files are merged with the current file, they can replace old data.\n\nThe _include_ keyword cannot appear inside a section, it must be a global property.\n\n```\ninclude a/file\n\n# Loads a/dir/index.properties\ninclude a/dir\n```\n\n---\n\n<a name=\"useful\"></a>\n__Useful options that you should always use__\n\nThere are too many options that you can enable but, which of them should you use? Well, this depends on what you need but I like to enable the following ones:\n\n- __json__: Parsing arrays is always very useful.\n- __namespaces__: Extremly useful if you want to organize your configuration files using namespaces and access the data using javascript objects. For example:\n\t\n\t```\n\tdb.pool.min 5\n\tdb.pool.max 10\n\t```\n\n\tInstead of:\n\t\n\t```\n\tdb_pool_min 5\n\tdb_pool_max 10\n\t```\n- __sections__: More organization. You don't need to write the first namespace level. For example:\n\n\t```\n\t[db]\n\tpool.min 5\n\tpool.max 10\n\t```\n\t\n\tInstead of:\n\t\n\t```\n\tdb.pool.min 5\n\tdb.pool.max 10\n\t```\n- __variables__: Writing the same thing again and again is a bad practice. Write it once and use a variable to copy the value wherever you want. With the variables enabled you can pass external variables to the file using the __vars__ option, which is pretty useful as shown in the [environment-vars](https://github.com/gagle/node-properties/blob/master/examples/variables/environment-vars.js) example.\n- __include__: Even more organization. I don't like to have a huge configuration file, I tend to have multiple smaller files. With this option I don't need to load all the files, I simply load the index file which includes all the files.\n\nWrapping this module it's also a good idea. This is a good starting point:\n\n```javascript\n//config.js\n\nvar properties = require (\"properties\");\n\nvar options = {\n\tpath: true,\n\tjson: true,\n\tnamespaces: true,\n\tsections: true,\n\tvariables: true,\n\tinclude: true\n};\n\nvar configDir = \"./path/to/config/dir\";\n\nmodule.exports.load = function (path, cb){\n\t//NODE_ENV can be \"production\" or \"development\"\n\t//Load specific configuration depending on the environment\n\tproperties.parse (configDir + \"/\" + process.env.NODE_ENV, options,\n\t\t\tfunction (error, env){\n\t\tif (error) return cb (error);\n\t\t\n\t\t//Pass the specific configuration as external variables to the common\n\t\t//configuration\n\t\toptions.vars = env;\n\t\t\n\t\t//If the path is a directory it tries to load the \"index.properties\" file\n\t\tproperties.parse (configDir, options, cb);\n\t});\n};\n```\n\nUsage:\n\n```javascript\nvar config = require (\"./config\");\n\nconfig.load (function (error, obj){\n\tif (error) return console.error (error);\n\t\n\t...\n});\n```\n\n---\n\n<a name=\"parse\"></a>\n___module_.parse(data[, options][, callback]) : undefined | Object__  \n\nParses a .properties string.\n\nIf a callback is given, the result is returned as the second parameter.\n\n```javascript\nobj = properties.parse ({ ... });\n\nproperties.parse ({ ... }, function (error, obj){\n\t//The \"error\" can be ignored, it is always null if the \"path\" option is not used\n});\n```\n\nOptions:\n\n- __path__ - _Boolean_  \n\t\tBy default `parse()` reads a String. If you want to read a file set this option to true. If this option is used the callback is mandatory. It gets 2 parameters, a possible error and the object with all the properties.\n- __comments__ - _String_ | _Array_  \n\tAllows you to add additional comment tokens. The token must be a single printable non-whitespae ascii character. If the `strict` option is not set, the tokens `#` and `!` are parsed as comment tokens.\n\t\n\t```javascript\n\tcomments: \";\"\n\tcomments: [\";\", \"@\"]\n\t```\n- __separators__ - _String_ | _Array_  \n\tAllows you to add additional separator tokens. The token must be a single printable non-whitespae ascii character. If the `strict` option is not set, the tokens `=` and `:` are parsed as comment tokens.\n\t\n\t```javascript\n\tseparators: \"-\"\n\tseparators: [\"-\", \">\"]\n\t```\n- __strict__ - _Boolean_  \n\tThis option can be used with the comments and separators options. If is set to true __only__ the tokens specified in these options are used to parse comments and separators.\n- __json__ - _Boolean_  \n\tTries to parse the property value as an array or object. See the [json](#json) section for further details.\n- __sections__ - _Boolean_  \n\tParses INI sections. See the [ini](#ini) section for further details.\n- __namespaces__ - _Boolean_  \n\tParses dot separated keys as javascript objects. See the [namespaces](#namespaces) section for further details.\n- __variables__ - _Boolean_  \n\tAllows you to read the value of a key while the file is being parsed. See the [variables](#variables) section for further details.\n- __vars__ - _Boolean_  \n\tExternal variables can be passed to the file if the variables option is enabled. See the [variables](#variables) section for further details.\n- __include__ - _Boolean_  \n\tFiles can be linked and imported with the `include` key.  If this option is used the callback is mandatory. See the [include](#include) section for further details.\n- __reviver__ - _Boolean_  \n\tEach property or section can be removed or modified from the final object. It's similar to the reviver of the JSON.parse function.\n\n\tThe reviver it's exatcly the same as the replacer from [stringify()](#stringify). The same function can be reused.\n\n\tThe callback gets 3 parameters: key, value and section.  \n\tA property has a key and a value and can belong to a section. If it's a global property the section is set to null. If __undefined__ is returned the property will be removed from the final object, otherwise the returned value will be used as the property value.  \n\tIf the key and the value are set to null then it's a section line. If it returns a falsy value it won't be added to the final object, the entire section -including all the properties- will be discarded. If it returns a truthy value the section is parsed.\n\t\n\tFor your convenience, to know if the line is a property or is a section, you can access to `this.isProperty` and `this.isSection` from inside the replacer function. Also, `this.assert()` can be used to return the _default_ value, the unmodified value that will be used to parse the line.\n\t\n\t`this.assert()` it's the same as:\n\t\n\t```javascript\n\tif (this.isProperty){\n\t\treturn value;\n\t}else{\n\t\t//isSection\n\t\treturn true;\n\t}\n\t```\n\t\n\tFor example, a reviver that does nothing and a reviver that removes all the lines:\n\t\n\t```javascript\n\tfunction (key, value, section){\n\t\t//Returns all the lines\n\t\treturn this.assert ();\n\t}\n\t```\n\t\n\t```javascript\n\tfunction (key, value, section){\n\t\t//Removes all the lines\n\t}\n\t```\n\t\n\tLook at the [reviver](https://github.com/gagle/node-properties/blob/master/examples/reviver/reviver.js) example for further details.\n\n---\n\n<a name=\"stringifier\"></a>\n___module_.stringifier([obj]) : Stringifier__\n\nCreates a new `Stringifier`. This class helps to stringify data when you want to add sections or comments.\n\nThe function accepts a parameter. If you pass an object it will be converted to a Stringifier. It's not very useful because [stringify()](#stringify) already converts automatically the object to a Stringifier.\n\n```javascript\nvar obj = { ... };\nvar stringifier = properties.stringifier (obj);\nproperties.stringify (stringifier);\n\n//The same as:\nproperties.stringify ({ ... });\n```\n---\n\n<a name=\"stringify\"></a>\n___module_.stringify(obj[, options][, callback]) : undefined | String__\n\nStringifies an object or a [Stringifier](#Stringifier).\n\nIf you don't need to add sections nor comments simply pass an object, otherwise use a Stringifier.\n\nIf a callback is given, the result is returned as the second parameter.\n\n```javascript\nstr = properties.stringify ({ ... });\n\nproperties.stringify ({ ... }, function (error, str){\n\t//The \"error\" can be ignored, it is always null if the \"path\" option is not used\n});\n```\n\nOptions:\n\n- __path__ - _String_  \n\tBy default `stringify()` returns a String and you decide what to do with it. If you want to write the final string to a file, give the path of a file. If this option is used the callback is mandatory. It gets two parameters, a possible error and the final string.\n- __comment__ - _String_  \n\tThe token to use to write comments. It must be a single printable non-whitespace ascii character. Default is `#`.\n- __separator__ - _String_  \n\tThe token to use to separate keys from values. It must be a single printable non-whitespace ascii character. Default is `=`.\n- __unicode__ - _Boolean_  \n\tThe .properties specification uses iso 8859-1 (latin-1) as a default encoding. In the other hand, Node.js has a utf8 default encoding. This means that if you want a full compatibility with Java, that is, you are generating a .properties file that is going to be read by a Java program, then set this option to true. This will encode all ascii extended and multibyte characters to their unicode string representation (`\\uXXXX`).\n\n\tNon-printable control codes (control sets 0 and 1) are always encoded as a unicode strings except `\\t`, `\\n`, `\\f` and `\\r`.\n\t\n\tIf you are in a system that can handle utf8 strings, e.g. Node.js, you don't need to use this option.\n- __replacer__ - _Function_\n\tEach property or section can be removed or modified from the final string. It's similar to the replacer of the JSON.stringify function.\n\n\tThe replacer it's exatcly the same as the reviver from [parse()](#parse). The same function can be reused.\n\n\tThe callback gets three parameters: key, value and section.  \n\tA property has a key and a value and can belong to a section. If it's a global property the section is set to null. If __undefined__ is returned the property won't be stringified, otherwise the returned value will be used as the property value.  \n\tIf the key and the value are set to null then it's a section line. If it returns a falsy value it won't be added to the final string, the entire section -including all the properties- will be discarded. If it returns a truthy value the section is stringified.\n\t\n\tFor your convenience, to know if the line is a property or is a section, you can access to `this.isProperty` and `this.isSection` from inside the replacer function. Also, `this.assert()` can be used to return the _default_ value, the unmodified value that will be used to stringify the line.\n\t\n\t`this.assert()` it's the same as:\n\t\n\t```javascript\n\tif (this.isProperty){\n\t\treturn value;\n\t}else{\n\t\t//isSection\n\t\treturn true;\n\t}\n\t```\n\t\n\tFor example, a replacer that does nothing and a replacer that removes all the lines:\n\t\n\t```javascript\n\tfunction (key, value, section){\n\t\t//Returns all the lines\n\t\treturn this.assert ();\n\t}\n\t```\n\t\n\t```javascript\n\tfunction (key, value, section){\n\t\t//Removes all the lines\n\t}\n\t```\n\t\n\tLook at the [replacer](https://github.com/gagle/node-properties/blob/master/examples/replacer.js) example for further details.\n\n---\n\n<a name=\"Stringifier\"></a>\n__Stringifier__\n\nThis class is used when you want to add sections or comments to the final string.\n\nTo create a Stringifier use the [stringifier()](#stringifier) function.\n\n__Methods__\n\n- [Stringifier#header(comment) : Stringifier](#Stringifier_header)\n- [Stringifier#property(obj) : Stringifier](#Stringifier_property)\n- [Stringifier#section(obj) : Stringifier](#Stringifier_section)\n\n<a name=\"Stringifier_header\"></a>\n__Stringifier#header(comment) : Stringifier__\n\nWrites a header comment. It will be written to the top of the final string. Returns the Stringifier being used.\n\n<a name=\"Stringifier_property\"></a>\n__Stringifier#property(obj) : Stringifier__\n\nWrites a property line. It takes an object with three options: `key`, `value` and `comment`. Both the key and the value are converted into a string automatically. Returns the Stringifier being used.\n\n```javascript\nstringifier\n\t//No value\n\t.property ({ key: \"a\" })\n\t.property ({ key: \"b\", value: [1, 2, 3] })\n\t//No key and no value\n\t.property ({ comment: \"empty\" })\n\n/*\na = \nb = [1,2,3]\n# empty\n = \n*/\n```\n\n<a name=\"Stringifier_section\"></a>\n__Stringifier#section(obj) : Stringifier__\n\nWrites a section line. It gets an object with two options: `name` and `comment`. The name is converted into a string. If you don't need to write a comment you can pass the name instead of an object. Returns the stringifier being used.\n\n```javascript\nstringifier.section (\"my section\");\n\n/*\n[my section]\n*/\n\nstringifier.section ({ name: \"my section\", comment: \"My Section\" });\n\n/*\n# My Section\n[my section]\n*/\n```\n\nLook at the [stringify-ini](https://github.com/gagle/node-properties/blob/master/examples/ini/stringify-ini.js) example for further details.",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/gagle/node-properties/issues"
  },
  "_id": "properties@1.0.3",
  "dist": {
    "shasum": "3bcf4d1aebc68a240283c6c8d54eb2e405b98c81"
  },
  "_from": "properties@*",
  "_resolved": "https://registry.npmjs.org/properties/-/properties-1.0.3.tgz"
}
